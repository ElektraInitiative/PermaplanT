/*
 Generated by typeshare 1.7.0
*/

/**
 * The payload of the [`Action::CreatePlanting`].
 * This struct should always match [`PlantingDto`].
 */
export interface CreatePlantActionPayload {
	userId: string;
	actionId: string;
	id: string;
	layerId: number;
	plantId: number;
	x: number;
	y: number;
	width: number;
	height: number;
	rotation: number;
	scaleX: number;
	scaleY: number;
	addDate?: string;
	removeDate?: string;
	seedId?: number;
}

/** The payload of the [`Action::DeletePlanting`]. */
export interface DeletePlantActionPayload {
	userId: string;
	actionId: string;
	id: string;
}

/** The payload of the [`Action::MovePlanting`]. */
export interface MovePlantActionPayload {
	userId: string;
	actionId: string;
	id: string;
	x: number;
	y: number;
}

/** The payload of the [`Action::TransformPlanting`]. */
export interface TransformPlantActionPayload {
	userId: string;
	actionId: string;
	id: string;
	x: number;
	y: number;
	rotation: number;
	scaleX: number;
	scaleY: number;
}

/**
 * The payload of the [`Action::CreateBaseLayerImage`].
 * This struct should always match [`BaseLayerImageDto`].
 */
export interface CreateBaseLayerImageActionPayload {
	userId: string;
	actionId: string;
	id: string;
	layerId: number;
	rotation: number;
	scale: number;
	path: string;
}

/** The payload of the [`Action::DeleteBaseLayerImage`]. */
export interface DeleteBaseLayerImageActionPayload {
	userId: string;
	actionId: string;
	id: string;
}

/** The payload of the [`Action::UpdateBaseLayerImage`]. */
export interface UpdateBaseLayerImageActionPayload {
	userId: string;
	actionId: string;
	id: string;
	layerId: number;
	rotation: number;
	scale: number;
	path: string;
}

/** The payload of the [`Action::UpdatePlantingAddDate`]. */
export interface UpdatePlantingAddDateActionPayload {
	userId: string;
	actionId: string;
	id: string;
	addDate?: string;
}

/** The payload of the [`Action::UpdatePlantingRemoveDate`]. */
export interface UpdatePlantingRemoveDateActionPayload {
	userId: string;
	actionId: string;
	id: string;
	removeDate?: string;
}

/**
 * Represents plant planted on a map.
 * E.g. a user drags a plant from the search results and drops it on the map.
 */
export interface PlantingDto {
	/** The id of the planting. */
	id: string;
	/** The plant layer the plantings is on. */
	layerId: number;
	/** The plant that is planted. */
	plantId: number;
	/** The x coordinate of the position on the map. */
	x: number;
	/** The y coordinate of the position on the map. */
	y: number;
	/** The width of the plant on the map. */
	width: number;
	/** The height of the plant on the map. */
	height: number;
	/** The rotation in degrees (0-360) of the plant on the map. */
	rotation: number;
	/** The x scale of the plant on the map. */
	scaleX: number;
	/** The y scale of the plant on the map. */
	scaleY: number;
	/**
	 * The date the planting was added to the map.
	 * If None, the planting always existed.
	 */
	addDate?: string;
	/**
	 * The date the planting was removed from the map.
	 * If None, the planting is still on the map.
	 */
	removeDate?: string;
	/** Plantings may be linked with a seed. */
	seedId?: number;
}

/** Used to create a new planting. */
export interface NewPlantingDto {
	/** The id of the planting. */
	id?: string;
	/** The plant layer the plantings is on. */
	layerId: number;
	/** The plant that is planted. */
	plantId: number;
	/** The x coordinate of the position on the map. */
	x: number;
	/** The y coordinate of the position on the map. */
	y: number;
	/** The width of the plant on the map. */
	width: number;
	/** The height of the plant on the map. */
	height: number;
	/** The rotation of the plant on the map. */
	rotation: number;
	/** The x scale of the plant on the map. */
	scaleX: number;
	/** The y scale of the plant on the map. */
	scaleY: number;
	/**
	 * The date the planting was added to the map.
	 * If None, the planting always existed.
	 */
	addDate?: string;
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
	/** Plantings may be linked with a seed. */
	seedId?: number;
}

/** Used to transform an existing planting. */
export interface TransformPlantingDto {
	/** The x coordinate of the position on the map. */
	x: number;
	/** The y coordinate of the position on the map. */
	y: number;
	/** The rotation of the plant on the map. */
	rotation: number;
	/** The x scale of the plant on the map. */
	scaleX: number;
	/** The y scale of the plant on the map. */
	scaleY: number;
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/** Used to move an existing planting. */
export interface MovePlantingDto {
	/** The x coordinate of the position on the map. */
	x: number;
	/** The y coordinate of the position on the map. */
	y: number;
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/** Used to change the `add_date` of a planting. */
export interface UpdateAddDatePlantingDto {
	/**
	 * The date the planting was added to the map.
	 * If None, the planting always existed.
	 */
	addDate?: string;
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/** Used to change the `remove_date` of a planting. */
export interface UpdateRemoveDatePlantingDto {
	/**
	 * The date the planting was removed from the map.
	 * If None, the planting is still on the map.
	 */
	removeDate?: string;
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/**
 * Used to delete a planting.
 * The id of the planting is passed in the path.
 */
export interface DeletePlantingDto {
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/** Query parameters for searching plantings. */
export interface PlantingSearchParameters {
	/** The id of the plant the planting references. */
	plant_id?: number;
	/** The id of the plants layer the planting is placed on. */
	layer_id?: number;
	/** Plantings that exist around this date are returned. */
	relative_to_date: string;
}

/** Contains configuration the frontend needs to run. */
export interface ConfigDto {
	/** The base URL of the authorization server */
	issuer_uri: string;
	/** The client_id the frontend should use to log in */
	client_id: string;
	/** The version must be an exact match between frontend and backend. */
	version: string;
}

export enum Quantity {
	Nothing = "nothing",
	NotEnough = "not enough",
	Enough = "enough",
	MoreThanEnough = "more than enough",
}

export enum Quality {
	Organic = "organic",
	NotOrganic = "not organic",
	Unknown = "unknown",
}

/** Represents seeds of a user. */
export interface SeedDto {
	/** The record id of the seed. */
	id: number;
	/** An additional name for the seed. */
	name: string;
	/** The variety of the seed. Currently unused. */
	variety?: string;
	/** The id of the plant this seed belongs to. */
	plant_id?: number;
	/** When the seeds were harvested. */
	harvest_year: number;
	/** How many seeds there are. */
	quantity: Quantity;
	/** When the seeds should be used by. */
	use_by?: string;
	/** Where the seeds came from. */
	origin?: string;
	/** What the seeds taste like. */
	taste?: string;
	/** The yield of the seeds. */
	yield_?: string;
	/** How many generations the seeds have been grown. */
	generation?: number;
	/** The quality of the seeds. */
	quality?: Quality;
	/** How much the seeds cost. */
	price?: number;
	/** Notes about the seeds. */
	notes?: string;
	/** The id of the owner of the seed. */
	owner_id: string;
	/**
	 * Timestamp indicating when the seed was archived.
	 * Empty if the seed was not archived.
	 */
	archived_at?: string;
}

export interface NewSeedDto {
	name: string;
	variety?: string;
	plant_id?: number;
	harvest_year: number;
	quantity: Quantity;
	use_by?: string;
	origin?: string;
	taste?: string;
	yield_?: string;
	generation?: number;
	quality?: Quality;
	price?: number;
	notes?: string;
}

/** Data that is required when archiving a seed. */
export interface ArchiveSeedDto {
	/** Whether the seed should be archived. */
	archived: boolean;
}

export enum PlantSpread {
	Narrow = "narrow",
	Medium = "medium",
	Wide = "wide",
	Na = "na",
}

/** The essential identifying information of a plant. */
export interface PlantsSummaryDto {
	/** The plants database id. */
	id: number;
	/** Biological name of this plant (E.g. "Triticum aestivum", "Prunus cerasus") */
	unique_name: string;
	/** A list of common english names (E.g. "Bread wheat", "Sour cherry") */
	common_name_en?: string[];
	/** How far a plant spreads (The 'width' of a plant) */
	spread?: PlantSpread;
}

/** Query parameters for searching plants. */
export interface PlantsSearchParameters {
	/** The system will check if this string occurs in the plants common name or unique name. */
	name?: string;
}

/** Query parameters for searching plant relations. */
export interface RelationSearchParameters {
	/** The id of the plant to find relations for. */
	plant_id: number;
}

/** Specifies the type of relation between two plants. */
export enum RelationType {
	/** If a plant works well with another plant. */
	Companion = "companion",
	/** If a plant is known to be neutral with another plant. */
	Neutral = "neutral",
	/** If a plant doesn't work well with another plant. */
	Antagonist = "antagonist",
}

/** Use to return a relation. */
export interface RelationDto {
	/** The id of the plant in the relation. */
	id: number;
	/** The type of relation. */
	relation: RelationType;
}

/** Use to return all relations for the plant. */
export interface RelationsDto {
	/** The id of the plant in the relation. */
	id: number;
	/** The type of relation. */
	relations: RelationDto[];
}

/** Indicates whether archived seeds should be returned in a seed query. */
export enum IncludeArchivedSeeds {
	/** Return only seeds that have not been archived. */
	NotArchived = "not_archived",
	/** Return only archived seeds. */
	Archived = "archived",
	/** Return all seeds */
	Both = "both",
}

/** Query parameters for searching seeds. */
export interface SeedSearchParameters {
	/** Name of the seed to search for. */
	name?: string;
	/** The exact harvest year of the seed. */
	harvest_year?: number;
	/**
	 * Whether archived, not archived or both kinds of seeds should be included.
	 * If no value is provided, a default value of NotArchived is assumed.
	 */
	archived?: IncludeArchivedSeeds;
}

/** Query parameters paginating list endpoints. */
export interface PageParameters {
	/** Number of results in per page. */
	per_page?: number;
	/**
	 * Page number to be returned.
	 * Note: pages start at one.
	 */
	page?: number;
}

/** A page of results returned from a list endpoint. */
export interface Page<T> {
	/** Resulting records. */
	results: T[];
	/** Current page number. */
	page: number;
	/** Results per page. */
	per_page: number;
	/** Number of pages in total. */
	total_pages: number;
}

/** A page of results bounded by time. */
export interface TimelinePage<T> {
	/** Resulting records. */
	results: T[];
	/** The time frame start date. */
	from: string;
	/** The time frame end date. */
	to: string;
}

/** Enum for map privacy setting options. */
export enum PrivacyOption {
	/** Data is private and only visible for owner or members, the data was explicitly shared with. */
	Private = "private",
	/** Data is protected and only visible for other members. */
	Protected = "protected",
	/** Data is public and visible for everyone. */
	Public = "public",
}

/** Support struct for transmitting latitude/longitude coordinates. */
export interface Coordinates {
	/** Latitude of the point. */
	latitude: number;
	/** Longitude of the point. */
	longitude: number;
}

/** The whole information of a map. */
export interface MapDto {
	/** The id of the map. */
	id: number;
	/** The name of the map. */
	name: string;
	/** The date the map was created. */
	creation_date: string;
	/** The date the map is supposed to be deleted. */
	deletion_date?: string;
	/** The date the last time the map view was opened by any user. */
	last_visit?: string;
	/** A flag indicating if this map is marked for deletion. */
	is_inactive: boolean;
	/** The zoom factor of the map. */
	zoom_factor: number;
	/** The amount of honors the map received. */
	honors: number;
	/** The amount of visits the map had. */
	visits: number;
	/** The amount of plants harvested on the map. */
	harvested: number;
	/** An enum indicating if this map is private or not. */
	privacy: PrivacyOption;
	/** The description of the map. */
	description?: string;
	/** The location of the map as a latitude/longitude point. */
	location?: Coordinates;
	/** The id of the owner of the map. */
	owner_id: string;
	/**
	 * The geometry of the map.
	 *
	 * E.g. `{"rings": [[{"x": 0.0,"y": 0.0},{"x": 1000.0,"y": 0.0},{"x": 1000.0,"y": 1000.0},{"x": 0.0,"y": 1000.0},{"x": 0.0,"y": 0.0}]],"srid": 4326}`
	 */
	geometry: object;
}

/** The information of a map necessary for its creation. */
export interface NewMapDto {
	/** The name of the map. */
	name: string;
	/** The date the map was created. */
	creation_date: string;
	/** The date the map is supposed to be deleted. */
	deletion_date?: string;
	/** The date the last time the map view was opened by any user. */
	last_visit?: string;
	/** A flag indicating if this map is marked for deletion. */
	is_inactive: boolean;
	/** The zoom factor of the map. */
	zoom_factor: number;
	/** The amount of honors the map received. */
	honors: number;
	/** The amount of visits the map had. */
	visits: number;
	/** The amount of plants harvested on the map. */
	harvested: number;
	/** An enum indicating if this map is private or not. */
	privacy: PrivacyOption;
	/** The description of the map. */
	description?: string;
	/** The location of the map as a latitude/longitude point. */
	location?: Coordinates;
	/**
	 * The geometry of the map.
	 *
	 * E.g. `{"rings": [[{"x": 0.0,"y": 0.0},{"x": 1000.0,"y": 0.0},{"x": 1000.0,"y": 1000.0},{"x": 0.0,"y": 1000.0},{"x": 0.0,"y": 0.0}]],"srid": 4326}`
	 */
	geometry: object;
}

/** The information for updating a map. */
export interface UpdateMapDto {
	/** The name of the map. */
	name?: string;
	/** An enum indicating if this map is private or not. */
	privacy?: PrivacyOption;
	/** The description of the map. */
	description?: string;
	/** The location of the map as a latitude/longitude point. */
	location?: Coordinates;
	/**
	 * The geometry of the map.
	 *
	 * E.g. `{"rings": [[{"x": 0.0,"y": 0.0},{"x": 1000.0,"y": 0.0},{"x": 1000.0,"y": 1000.0},{"x": 0.0,"y": 1000.0},{"x": 0.0,"y": 0.0}]],"srid": 4326}`
	 */
	geometry?: object;
}

/** Query parameters for searching maps. */
export interface MapSearchParameters {
	/** Name of the map to search for. */
	name?: string;
	/** Whether or not the map is active. */
	is_inactive?: boolean;
	/** The owner of the map. */
	owner_id?: string;
	/** The selected privacy of the map. */
	privacy?: PrivacyOption;
}

/** Enum for all possible layer types. */
export enum LayerType {
	/** Identifier for Base Layer. */
	Base = "base",
	/** Identifier for Soil Layer. */
	Soil = "soil",
	/** Identifier for Todo Layer. */
	Todo = "todo",
	/** Identifier for Label Layer. */
	Label = "label",
	/** Identifier for Paths Layer. */
	Paths = "paths",
	/** Identifier for Photo Layer. */
	Photo = "photo",
	/** Identifier for Shade Layer. */
	Shade = "shade",
	/** Identifier for Trees Layer. */
	Trees = "trees",
	/** Identifier for Winds Layer. */
	Winds = "winds",
	/** Identifier for Zones Layer. */
	Zones = "zones",
	/** Identifier for Plants Layer. */
	Plants = "plants",
	/** Identifier for Drawing Layer. */
	Drawing = "drawing",
	/** Identifier for Terrain Layer. */
	Terrain = "terrain",
	/** Identifier for Habitats Layer. */
	Habitats = "habitats",
	/** Identifier for Warnings Layer. */
	Warnings = "warnings",
	/** Identifier for Watering Layer. */
	Watering = "watering",
	/** Identifier for Landscape Layer. */
	Landscape = "landscape",
	/** Identifier for Hydrology Layer. */
	Hydrology = "hydrology",
	/** Identifier for Fertilization Layer. */
	Fertilization = "fertilization",
	/** Identifier for Infrastructure Layer. */
	Infrastructure = "infrastructure",
}

/** The whole information of a map version. */
export interface LayerDto {
	/** The id of the layer. */
	id: number;
	/** The id of the map this layer belongs to. */
	map_id: number;
	/** The type of layer. */
	type_: LayerType;
	/** The name of the layer. */
	name: string;
	/** A flag indicating if this layer is an user created alternative. */
	is_alternative: boolean;
}

/** The information of a layer neccessary for its creation. */
export interface NewLayerDto {
	/** The id of the map this layer belongs to. */
	map_id: number;
	/** The type of layer. */
	type_: LayerType;
	/** The name of the layer. */
	name: string;
	/** A flag indicating if this layer is an user created alternative. */
	is_alternative: boolean;
}

/** Query parameters for searching layers. */
export interface LayerSearchParameters {
	/** The parent map. */
	map_id?: number;
	/** The type of layer. */
	type_?: LayerType;
	/** Whether or not the layer is an alternative. */
	is_alternative?: boolean;
}

/** Query parameters for connecting to a map. */
export interface ConnectToMapQueryParams {
	/** The id of the map to connect to. */
	map_id: number;
	/** The id of the user connecting to the map. */
	user_id: string;
}

/** Kind of suggestion. */
export enum SuggestionType {
	/** Suggests plants that are available for planting. */
	Available = "available",
	/** Suggests plants based on diversity criteria. */
	Diversity = "diversity",
}

/** Search parameters for plant suggestions. */
export interface PlantSuggestionsSearchParameters {
	/** The kind of suggestion returned by the endpoint. */
	suggestion_type: SuggestionType;
	/**
	 * Date representing the season to search for.
	 * Only the month and day are used, nevertheless it must be an existing date.
	 */
	relative_to_date: string;
}

/** Contains information about an image displayed on the base layer. */
export interface BaseLayerImageDto {
	/** The id of the image. */
	id: string;
	/** The layer the image is on. */
	layer_id: number;
	/** The path to the image on Nextcloud. */
	path: string;
	/** The rotation in degrees (0-360) of the image on the map. */
	rotation: number;
	/** The scale of the image on the map. */
	scale: number;
	/** Id of the action (for identifying the action in the frontend). */
	action_id: string;
}

/** Contains information for updating the `BaseLayerImage`. */
export interface UpdateBaseLayerImageDto {
	/** The layer the image is on. */
	layer_id: number;
	/** The path to the image on Nextcloud. */
	path: string;
	/** The rotation in degrees (0-360) of the image on the map. */
	rotation: number;
	/** The scale of the image on the map. */
	scale: number;
	/** Id of the action (for identifying the action in the frontend). */
	action_id: string;
}

/**
 * Used to delete a base layer image.
 * The id of the base layer image is passed in the path.
 */
export interface DeleteBaseLayerImageDto {
	/** Id of the action (for identifying the action in the frontend). */
	actionId: string;
}

/** Query parameters to configure the generation of the heatmap. */
export interface HeatMapQueryParams {
	/** The id of the plant layer the planting will be planted on. */
	layer_id: number;
	/** The id of the plant you want to plant. */
	plant_id: number;
}

/** Enum for all possible salutations. */
export enum Salutation {
	/** female neutral salutation. */
	Ms = "ms",
	/** female married salutation. */
	Mrs = "mrs",
	/** male salutation. */
	Mr = "mr",
	/** gender neutral salutation. */
	Mx = "mx",
}

/** Enum for all possible experience levels. */
export enum Experience {
	/** Beginner in permaculture. */
	Beginner = "beginner",
	/** Advanced in permaculture. */
	Advanced = "advanced",
	/** Expert in permaculture. */
	Expert = "expert",
}

/** Enum containing all possible membership types. */
export enum Membership {
	/** Membership type for supporting PermaplanT financially. */
	Supporting = "supporting",
	/** Membership type for regular PermaplanT membership. */
	Regular = "regular",
	/** Membership type for enjoying PermaplanT by helping others. */
	Contributing = "contributing",
}

/** All of the application managed user data. */
export interface UsersDto {
	/** The preferred salutation of the user. */
	salutation: Salutation;
	/** The title(s) of the user. */
	title?: string;
	/** The current country of the user. */
	country: string;
	/** The phone number of the user. */
	phone?: string;
	/** The website of the user. */
	website?: string;
	/** The organization the user belongs to. */
	organization?: string;
	/** The experience level in permaculture of the user. */
	experience?: Experience;
	/** The membership type of the user. */
	membership?: Membership;
	/** A collection of years in which the user was a member. */
	member_years?: number[];
	/** The date since when the user is a member. */
	member_since?: string;
	/** The amount of permacoins the user earned in each year as a member. */
	permacoins?: number[];
}

/** Completion status of all Guided Tours. */
export interface GuidedToursDto {
	/** Whether or not the Map Editor Guided Tour was completed. */
	editor_tour_completed: boolean;
}

/** The information for updating an users Guided Tour status. */
export interface UpdateGuidedToursDto {
	/** Whether or not the Map Editor Guided Tour was completed. */
	editor_tour_completed?: boolean;
}

/** Information on a specific Blossom gained by a user. */
export interface GainedBlossomsDto {
	/** The title of the Blossom. */
	blossom: string;
	/** The number of times this Blossom was gained by this user. */
	times_gained: number;
	/** The date on which the user gained this Blossom. */
	gained_date: string;
}

/** An enum representing all the actions that can be broadcasted via [`crate::sse::broadcaster::Broadcaster`]. */
export type Action =
	/** An action used to broadcast creation of a plant. */
	| { type: "CreatePlanting", payload: CreatePlantActionPayload }
	/** An action used to broadcast deletion of a plant. */
	| { type: "DeletePlanting", payload: DeletePlantActionPayload }
	/** An action used to broadcast movement of a plant. */
	| { type: "MovePlanting", payload: MovePlantActionPayload }
	/** An action used to broadcast transformation of a plant. */
	| { type: "TransformPlanting", payload: TransformPlantActionPayload }
	/** An action used to broadcast creation of a baseLayerImage. */
	| { type: "CreateBaseLayerImage", payload: CreateBaseLayerImageActionPayload }
	/** An action used to broadcast update of a baseLayerImage. */
	| { type: "UpdateBaseLayerImage", payload: UpdateBaseLayerImageActionPayload }
	/** An action used to broadcast deletion of a baseLayerImage. */
	| { type: "DeleteBaseLayerImage", payload: DeleteBaseLayerImageActionPayload }
	/** An action used to update the `add_date` of a plant. */
	| { type: "UpdatePlantingAddDate", payload: UpdatePlantingAddDateActionPayload }
	/** An action used to update the `remove_date` of a plant. */
	| { type: "UpdatePlantingRemoveDate", payload: UpdatePlantingRemoveDateActionPayload };

/**
 * Used to differentiate between different update operations on plantings.
 *
 * Ordering of enum variants is important.
 * Serde will try to deserialize starting from the top.
 */
export type UpdatePlantingDto =
	/** Transform a plantings. */
	| { type: "Transform", content: TransformPlantingDto }
	/** Move a plantings an the map. */
	| { type: "Move", content: MovePlantingDto }
	/** Change the `add_date` of a planting. */
	| { type: "UpdateAddDate", content: UpdateAddDatePlantingDto }
	/** Change the `remove_date` of a planting. */
	| { type: "UpdateRemoveDate", content: UpdateRemoveDatePlantingDto };

export enum DeciduousOrEvergreen {
	Deciduous = "deciduous",
	Evergreen = "evergreen",
}

export enum ExternalSource {
	PracticalPlants = "practicalplants",
	PermaPeople = "permapeople",
	Reinsaat = "reinsaat",
}

export enum Fertility {
	SelfFertile = "self fertile",
	SelfSterile = "self sterile",
}

export enum FlowerType {
	Dioecious = "dioecious",
	Monoecious = "monoecious",
	Hermaphrodite = "hermaphrodite",
}

export enum GrowthRate {
	Slow = "slow",
	Moderate = "moderate",
	Vigorous = "vigorous",
}

export enum HerbaceousOrWoody {
	Herbaceous = "herbaceous",
	Woody = "woody",
}

export enum LifeCycle {
	/** on the map for current year */
	Annual = "annual",
	/** on the map for current and next year */
	Biennial = "biennial",
	/** on the map until removed by user */
	Perennial = "perennial",
}

export enum LightRequirement {
	FullShade = "full shade",
	Partial = "partial sun/shade",
	Full = "full sun",
}

export enum NutritionDemand {
	LightFeeder = "light feeder",
	ModerateFeeder = "moderate feeder",
	HeavyFeeder = "heavy feeder",
}

export enum PlantHeight {
	Low = "low",
	Medium = "medium",
	High = "high",
	Na = "na",
}

export enum PropagationMethod {
	SeedDirectSow = "seed - direct sow",
	SeedTransplant = "seed - transplant",
	Division = "division",
	Cuttings = "cuttings",
	Layering = "layering",
	Spores = "spores",
	Seed = "seed",
}

export enum Shade {
	NoShade = "no shade",
	LightShade = "light shade",
	PartialShade = "partial shade",
	PermanentShade = "permanent shade",
	PermanentDeepShade = "permanent deep shade",
}

export enum SoilPh {
	VeryAcidic = "very acid",
	Acidic = "acid",
	Neutral = "neutral",
	Alkaline = "alkaline",
	VeryAlkaline = "very alkaline",
}

export enum SoilTexture {
	Sandy = "sandy",
	Loamy = "loamy",
	Clay = "clay",
	HeavyClay = "heavy clay",
}

export enum SoilWaterRetention {
	WellDrained = "well drained",
	Moist = "moist",
	Wet = "wet",
}

/** Enum containing all possible Blossom tracks. */
export enum Track {
	/** Track for Blossoms aimed at new users. */
	Beginner = "beginner",
	/** Track for Blossoms aimed to be repeated every season. */
	Seasonal = "seasonal",
	/** Track for Blossoms aimed at users that want to do everything PermaplanT has to offer. */
	Completionist = "completionist",
	/** Track for Blossoms aimed at user that want to prove their expertise by helping others. */
	Expert = "expert",
}

/**
 * *Used* in hydrology layer.
 * *Fetched from* PracticalPlants and Permapeople (merged with `water` of PracticalPlants).
 */
export enum WaterRequirement {
	/** well drained, little water input */
	Dry = "dry",
	/** regular water supply, e.g. flat bed with humus */
	Moist = "moist",
	/** drowned, (often) flooded or in general very moist, e.g. swamp */
	Wet = "wet",
	/** completely aquatic */
	Water = "water",
}
