def abortPreviousRunUnlessMaster() {
  // We never want to abort builds of the master branch
  if (env.BRANCH_NAME=="master") return;
  def exec = currentBuild
             ?.rawBuild
             ?.getPreviousBuildInProgress()
             ?.getExecutor()
  if(exec) {
    exec.interrupt(
      Result.ABORTED,
      new CauseOfInterruption.UserInterruption(
        "Aborted by Build#${currentBuild.number}"
      )
    )
  }
}
abortPreviousRunUnlessMaster()

def node_info() {
    echo "Running stage on ${env.NODE_NAME}"
}

def wait_for_db() {
    retry(6) {
        sleep(time: 5, unit: 'SECONDS')
        sh '/usr/bin/pg_isready --host=db --username=ci --dbname=ci --timeout=10'
    }
}

def wait_for_backend() {
    retry(6) {
        sleep(time: 30, unit: 'SECONDS')
        sh ''
    }
}

// REQUIRED for Deployment
// see Jenkinsfile.release
// stage('Build Schema'){
//     node('docker') {
//         node_info()
//         checkout scm

//         def rust_image = docker.build("permaplant-rust", "./ci/container-images/permaplant-rust")

//         docker.image('postgis/postgis:13-3.1').withRun('-e "POSTGRES_USER=ci" -e "POSTGRES_PASSWORD=ci"') { c ->
//             rust_image.inside("--link ${c.id}:db -e 'DATABASE_URL=postgres://ci:ci@db/ci'") {
//                 checkout scm

//                 wait_for_db()

//                 sh './ci/build-scripts/build-schema.sh'

//                 stash includes: 'backend/src/schema.rs', name: 'schema.rs'
//                 stash includes: 'frontend/src/bindings/definitions.ts', name: 'definitions.ts'
//             }
//         }
//     }
// }


// NOT REQUIRED for Deployment
// stage('Tests & Build') {
//     def parallel_checks = [:]

//     parallel_checks["test-and-build-mdbook"] = {
//         node('docker') {
//             checkout scm
//             def mdbook_image = docker.build("permaplant-mdbook", "./ci/container-images/permaplant-mdbook")

//             mdbook_image.inside {
//                 checkout scm

//                 stage('test-and-build-mdbook'){
//                     sh "mdbook test"
//                     sh 'mdbook build'
//                     stash includes: 'book/', name: 'mdbook'
//                 }
//             }
//         }
//     }

//     // parallel_checks["test-and-build-backend"] = {
//     //     node('docker') {
//     //         node_info()
//     //         checkout scm
//     //         def rust_image = docker.build("permaplant-rust", "./ci/container-images/permaplant-rust")

//     //         docker.image('postgis/postgis:13-3.1').withRun('-e "POSTGRES_USER=ci" -e "POSTGRES_PASSWORD=ci"') { c ->
//     //             rust_image.inside("--link ${c.id}:db -e 'DATABASE_URL=postgres://ci:ci@db/ci'") {
//     //                 checkout scm

//     //                 wait_for_db()

//     //                 stage('test-backend'){
//     //                     withEnv(['RUSTFLAGS=-D warnings', 'RUSTDOCFLAGS=-D warnings']) {
//     //                         // Workaround: we can't stop rustfmt from linting the generated schema.rs
//     //                         dir("backend") {
//     //                             sh "/bin/bash -c 'echo \"\" > src/schema.rs'"
//     //                             sh "cargo fmt --check"
//     //                         }
//     //                         // End of Workaround

//     //                         // generate schema (overwriting src/schema.rs)
//     //                         sh './ci/build-scripts/build-schema.sh'

//     //                         dir("backend") {
//     //                             // continue checking
//     //                             withEnv(['BIND_ADDRESS_HOST=127.0.0.1', 'BIND_ADDRESS_PORT=8080', 'AUTH_DISCOVERY_URI=unused', 'AUTH_CLIENT_ID=unused']) {
//     //                             sh "cargo check"
//     //                             sh "cargo clippy"
//     //                             sh "cargo doc"
//     //                             sh "cargo test"
//     //                             }
//     //                         }
//     //                     }
//     //                 }

//     //                 stage('build-backend'){
//     //                     sh './ci/build-scripts/build-backend.sh'

//     //                     stash includes: 'backend/target/release/backend', name: 'backend'
//     //                 }
//     //             }
//     //         }
//     //     }
//     // }

//     parallel_checks["test-and-build-frontend"] = {
//         node('docker') {
//             node_info()
//             checkout scm
//             def node_image = docker.build("permaplant-node", "./ci/container-images/permaplant-node")

//             node_image.inside {
//                 checkout scm
//                 unstash 'definitions.ts'
//                 stage('test-frontend'){
//                     dir("frontend") {
//                         sh "npm ci"
//                         sh "npm run format:check"
//                         sh "npm run lint"
//                         sh "npm run test"
//                     }
//                 }

//                 stage('build-frontend'){
//                     sh './ci/build-scripts/build-frontend.sh'
//                     stash includes: 'frontend/dist/**/*', name: 'frontend'
//                 }

//                 stage('build-typedoc'){
//                     sh 'cd frontend && npm run doc'
//                     stash includes: 'frontend/src/generated/docs/', name: 'typedoc'
//                 }

//                 stage('build-storybook'){
//                     sh './ci/build-scripts/build-storybook.sh'
//                     stash includes: 'frontend/storybook-static/**/*', name: 'storybook'
//                 }
//             }
//         }
//     }
//     parallel(parallel_checks)
// }

stage('Acceptance Test'){
    timeout(time: 20, unit: 'MINUTES'){
        node('docker') {
            node_info()
            checkout scm

            def selenium_image = docker.build("permaplant-selenium", "./ci/container-images/permaplant-selenium")
            def node_image = docker.build("permaplant-node", "./ci/container-images/permaplant-node")
            def rust_image = docker.build("permaplant-rust", "./ci/container-images/permaplant-rust")

            selenium_image.withRun('-e "POSTGRES_USER=ci" -e "POSTGRES_PASSWORD=ci"') { s ->
                docker.image('myhub.hub/selenium-dev').inside("--link ${s.id}:se") {
                    checkout scm
                    sh 'pwd'
                }

                docker.image('postgis/postgis:13-3.1').inside("--link ${s.id}:se").withRun('-e "POSTGRES_USER=ci" -e "POSTGRES_PASSWORD=ci"') { c ->
                    rust_image.inside("--link ${c.id}:db --link ${s.id}:se -e 'DATABASE_URL=postgres://ci:ci@db/ci'") {
                        checkout scm
                        sh 'pwd'
                    }
                }
                node_image.inside("--link ${s.id}:se") {
                    checkout scm
                    sh 'pwd'
                }
            }
        }
    }
}

stage('Deploy PR') {
    node('permaplant && pr') {
        node_info()

        checkout scm

        echo "Workspace is '${WORKSPACE}'"
        echo 'Ensure pr service is stopped'
        sh 'sudo /usr/sbin/service permaplant-pr stop'

        withEnv(['DATABASE_URL=postgres://cidb:cidb@127.0.0.1/cidb']) {
            echo 'Resetting the CI DB ...'
            sh 'sudo /usr/local/bin/permaplant-reset-ci.sh'

            echo "Unstash Artifacts"
            unstash 'schema.rs'
            unstash 'frontend'
            unstash 'backend'
            unstash 'storybook'
            unstash 'typedoc'
            unstash 'mdbook'

            echo 'Deploying to PR'
            sh "sudo /usr/local/bin/permaplant-deploy.sh pr ${WORKSPACE}"

            echo 'Loading Data to PR'
            dir('scraper') {
                sh 'npm ci'
                sh 'mkdir ./data/'
                sh 'cp /nextcloud/mergedDatasets.csv ./data/'
                sh 'npm run insert'
                sh 'rm -rf ./data/'
                sh 'rm -rf ./node_modules/'
            }
        }
    }
}

// Deploying to Dev only happens on branch "master"
if (env.BRANCH_NAME == 'master') {
    try {
        stage('Deploy Dev') {
            node('permaplant && dev') {
                node_info()

                checkout scm

                echo "Unstash Artifacts"
                unstash 'schema.rs'
                unstash 'frontend'
                unstash 'backend'
                unstash 'storybook'
                unstash 'typedoc'
                unstash 'mdbook'

                echo 'Deploying to Dev ...'
                sh "sudo /usr/local/bin/permaplant-deploy.sh dev ${WORKSPACE}"
            }
        }
    } catch(Exception e) {
        // If master is failing we want to know ASAP so send a mail.
        // collect changes since last build
        def changes = currentBuild.changeSets.collect() {
        it.collect() {
            "* ${it.getCommitId().take(7)} - ${it.getAuthor()} - ${it.getMsg().take(40)}"
        }.join('\n')
        }.join('\n')
        if (!changes) {
        changes = "* No new changes since last build"
        }

        def message = """\
Build ${JOB_NAME}:${BUILD_NUMBER} failed.
Url: ${RUN_DISPLAY_URL}
Reason: ${e}

Changes: ${RUN_CHANGES_DISPLAY_URL}
${changes}

Logs: ${currentBuild.rawBuild.getLog(20).join('\n')}
"""
    mail subject: "Build ${JOB_NAME} failed",
        body: message,
        replyTo: "noreply@libelektra.org",
        to: "build@libelektra.org"
    }
}

// PRODUCTION DEPLOYMENT
// see Jenkinsfile.release
